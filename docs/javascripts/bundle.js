/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./entry.js":
/*!******************!*\
  !*** ./entry.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _3NF_SYNTHESIS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! 3NF_SYNTHESIS */ \"../node_modules/3NF_SYNTHESIS/index.js\");\n/* harmony import */ var _3NF_SYNTHESIS__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_3NF_SYNTHESIS__WEBPACK_IMPORTED_MODULE_0__);\n\n;\n\nconst FdRelationScheme = (_3NF_SYNTHESIS__WEBPACK_IMPORTED_MODULE_0___default().FdRelationScheme)\n\nconst R1 = new FdRelationScheme(\n  'test',\n  ['A', 'B', 'C', 'D', 'E'],\n  [\n    [['A'], ['C']],\n    [['B'], ['C', 'D']],\n    [['C'], ['E']],\n    [['E'], ['C']],\n    [['D'], ['B']]\n  ]\n)\n\nconst keys = R1.find_all_keys()\n\nalert(JSON.stringify(keys.size))\n\n\n//# sourceURL=webpack:///./entry.js?");

/***/ }),

/***/ "../node_modules/3NF_SYNTHESIS/index.js":
/*!**********************************************!*\
  !*** ../node_modules/3NF_SYNTHESIS/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst util = __webpack_require__(/*! ./lib/util */ \"../node_modules/3NF_SYNTHESIS/lib/util.js\")\nconst set_operation = util.set_operation\n\n/**\n * Receive pair and return fd\n *\n * @param {Array<Array<string>} array_fd - first element and second element mean lhs and rhs respectively. array_fd may be destructed.\n *\n * @returns {string}\n *\n * @example\n * array_fd [['A'], ['C', 'B']] means A->BC and returns string [[\"A\"],[\"B\",\"C\"]]\n * array_fd [['school', 'classroom', 'classroom'] , ['teacher']] (classroom duplicated)  means `school` and `classroom` determine `teacher`\n *   returns string [[\"classroom\",\"classroom\",\"school\"],[\"teacher\"]]\n *\n */\nfunction generate_fd(array_fd) {\n  validate_array_fd(array_fd)\n\n  const lhs = [...new Set(array_fd[0])]\n  const rhs = [...new Set(array_fd[1])]\n\n  lhs.sort()\n  rhs.sort()\n\n  return JSON.stringify([lhs, rhs])\n}\n\n/**\n * validate a fd expressed by array\n *\n * @param {Array<Array<string>>} array_fd - a fd expressed by array\n * @throws {TypeError}\n * @throws {RangeError}\n */\nfunction validate_array_fd(array_fd) {\n  if (util.get_type(array_fd) !== 'array') {\n    throw new TypeError('array_fd must be array. array_fd: ' + JSON.stringify(array_fd))\n  }\n\n  if (array_fd.length !== 2) {\n    throw new RangeError('array_fd length must be 2. array_fd: ' + JSON.stringify(array_fd))\n  }\n\n  if (util.get_type(array_fd[0]) !== 'array') {\n    throw new TypeError('array_fd[0] must be array. array_fd: ' + JSON.stringify(array_fd))\n  }\n\n  if (util.get_type(array_fd[1]) !== 'array') {\n    throw new TypeError('array_fd[1] must be array. array_fd: ' + JSON.stringify(array_fd))\n  }\n}\n\n/**\n * validate a fd expressed by string or array\n *\n * @param {string} fd - a fd expressed by string or array\n * @throws {SyntaxError}\n * @throws {TypeError}\n * @throws {RangeError}\n */\nfunction validate_fd(fd) {\n  const fd_type = util.get_type(fd)\n  let array_fd = null\n\n  if (fd_type === 'array') {\n    array_fd = fd\n  } else if (fd_type === 'string') {\n    try {\n      array_fd = get_as_object(fd)\n    }\n    catch (err) {\n      // SyntaxError\n      throw err\n    }\n  } else {\n    throw new TypeError('invalid fd expression: ' + JSON.stringify(fd))\n  }\n\n  validate_array_fd(array_fd)\n}\n\n/**\n * get fd as object\n *\n * @param {string} fd - functional dependency\n */\nfunction get_as_object(fd) {\n  const obj = JSON.parse(fd)\n\n  return obj\n}\n\n/**\n * get the lhs of a given fd\n *\n * @param {string} fd - functioal dependency\n * @returns {Array<string>} lhs\n */\nfunction get_lhs(fd) {\n  const obj = get_as_object(fd)\n\n  return obj[0]\n}\n\n/**\n * get the rhs of a given fd\n *\n * @param {string} fd - functioal dependency\n * @returns {Array<string>} rhs\n */\nfunction get_rhs(fd) {\n  const obj = get_as_object(fd)\n\n  return obj[1]\n}\n\nclass FdRelationScheme {\n  /** @type {string} */\n  name;\n  /** @type {Set<string>} */\n  attributes;\n  /** @type {Set<string>} */\n  fds;\n\n  /**\n   * @param {string} name relation name\n   * @param {Set<string> | Array<string>} attributes\n   * @param {Set<string | Array<Array<string>>> | Array<string | Array<Array<string>>>} fds functional dependencies\n   * @throws {TypeError} - thrown if attributes and fds is not either set or array\n   * @throws {RangeError} - thrown if one or more of the attributes in a Fd aren't in the set of all the attribtues\n   */\n  constructor(name, attributes, fds) {\n    this.name = name\n\n    const attributes_type = util.get_type(attributes)\n    if (attributes_type === 'set') {\n      this.attributes = attributes\n    } else if (attributes_type === 'array') {\n      this.attributes = new Set(attributes)\n    } else {\n      throw new TypeError('Attributes must be Set or Array. attributes: ' + JSON.stringify(attributes));\n    }\n\n    const fds_type = util.get_type(fds)\n    if (!(fds_type === 'set' || fds_type === 'array')) {\n      throw new TypeError('fds must be Set or Array. fds: ' + JSON.stringify(fds));\n    }\n    this.fds = new Set()\n\n    // validate attribtues and fds\n    for (const elem of fds) {\n      const elem_type = util.get_type(elem)\n      let fd = ''\n      if (elem_type === 'array') {\n        fd = generate_fd(elem)\n      } else if (elem_type === 'string') {\n        validate_fd(elem)\n        fd = elem\n      } else {\n        throw new TypeError('elem must be array or string. elem: ' + elem);\n      }\n      for (const attribute of get_lhs(fd)) {\n        if (!this.attributes.has(attribute)) {\n          throw new RangeError(attribute + ' is not in ' + this.attributes + '.')\n        }\n      }\n\n      for (const attribute of get_rhs(fd)) {\n        if (!this.attributes.has(attribute)) {\n          throw new RangeError(attribute + ' is not in ' + this.attributes + '.')\n        }\n      }\n\n      this.fds.add(fd)\n    }\n\n  }\n\n  /**\n   * find the closure of attributes\n   *\n   * @param {Set<string> | Array<string>} attributes - Attribute set of which we want to find a closure\n   * @param {Set<string>} [fds] - functional dependencies\n   * @returns {Set<string>} closure\n   */\n  find_closure_of_attributes(attributes, fds = this.fds) {\n    let closure = new Set(attributes)\n\n    while (true) {\n      const previous = closure\n      for (const fd of fds) {\n        const lhs = new Set(get_lhs(fd))\n        const rhs = new Set(get_rhs(fd))\n        if (set_operation.is_superset(previous, lhs)) {\n          closure = set_operation.union(closure, rhs)\n        }\n      }\n\n      if (set_operation.is_superset(previous, closure)) {\n        break\n      }\n    }\n\n    return closure\n  }\n\n  /**\n   * check a given fds are equivalent to the original\n   *\n   * @param {Array<Array<Array<string>> | string>} fds - a given fds\n   * @param {Set<string>} [fds_to_compare] - functional dependencies to compare with\n   * @throws {RangeError} - thrown if one or more of the attributes in a Fd aren't in the set of all the attribtues\n   * @returns {boolean}\n   */\n  check_fds_are_equivalent(fds, fds_to_compare = this.fds) {\n    let given_fds = new Set()\n\n    for (const elem of fds) {\n      const elem_type = util.get_type(elem)\n      let fd = ''\n      if (elem_type === 'array') {\n        fd = generate_fd(elem)\n      } else if (elem_type === 'string') {\n        validate_fd(elem)\n        fd = elem\n      } else {\n        throw new TypeError('elem must be array or string. elem: ' + elem);\n      }\n      for (const attribute of get_lhs(fd)) {\n        if (!this.attributes.has(attribute)) {\n          throw new RangeError(attribute + ' is not in ' + this.attributes + '.')\n        }\n      }\n\n      for (const attribute of get_rhs(fd)) {\n        if (!this.attributes.has(attribute)) {\n          throw new RangeError(attribute + ' is not in ' + this.attributes + '.')\n        }\n      }\n\n      given_fds.add(fd)\n    }\n\n    // check this.fds+ >= given_fds+\n    for (const fd of given_fds) {\n      const closure = this.find_closure_of_attributes(get_lhs(fd), fds_to_compare)\n      if (!set_operation.is_superset(closure, new Set(get_rhs(fd)))) {\n        return false\n      }\n    }\n\n    // check this.fds+ <= given_fds+\n    for (const fd of fds_to_compare) {\n      const closure = this.find_closure_of_attributes(get_lhs(fd), given_fds)\n      if (!set_operation.is_superset(closure, new Set(get_rhs(fd)))) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * check whether fds of a given scheme are a minimal cover\n   *\n   * @param {Set<string>} fds - functional dependencies\n   * @returns {boolean}\n   */\n  is_minimal(fds = this.fds) {\n    if (!(set_operation.every(fds, fd => get_rhs(fd).length === 1))) {\n      return false\n    }\n\n    for (const fd of fds) {\n      const new_fds = new Set(fds)\n      new_fds.delete(fd)\n      for (const attr of get_lhs(fd)) {\n        const array_fd = get_as_object(fd)\n        const array_fd_lhs = array_fd[0]\n        const new_array_fd_lhs = array_fd_lhs.filter(item => item !== attr)\n        array_fd[0] = new_array_fd_lhs\n        const new_fd = generate_fd(array_fd)\n        new_fds.add(new_fd)\n        if (this.check_fds_are_equivalent(new_fds, fds)) {\n          return false\n        }\n        new_fds.delete(new_fd)\n      }\n    }\n\n    for (const fd of fds) {\n      const new_fds = new Set(fds)\n      new_fds.delete(fd)\n      if (this.check_fds_are_equivalent(new_fds, fds)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * find a minimal cover\n   *\n   * @param {Set<string>} fds - functional dependencies\n   * @returns {Set<string>}\n   */\n  find_minimal_cover(fds = this.fds) {\n    // step 1\n    let result_fds = new Set(fds)\n\n    // step 2\n    for (const fd of result_fds) {\n      const array_fd = get_as_object(fd)\n      if (array_fd[1].length !== 1) {\n        result_fds.delete(fd)\n        for (const attr of array_fd[1]) {\n          const new_fd = generate_fd([array_fd[0], [attr]])\n          result_fds.add(new_fd)\n        }\n      }\n    }\n\n    // step 3\n    for (const fd of new Set(result_fds)) {\n      const array_fd = get_as_object(fd)\n      const base = new Set(result_fds)\n      base.delete(fd)\n      for (const attr of Array.from(array_fd[0])) {\n        const base2 = new Set(base)\n        const original_lhs = array_fd[0]\n        const new_lhs = array_fd[0].filter(item => item !== attr)\n        array_fd[0] = new_lhs\n        const fd_to_add = generate_fd(array_fd)\n        base2.add(fd_to_add)\n        if (this.check_fds_are_equivalent(base2, result_fds)) {\n          result_fds = new Set(base2)\n        } else {\n          array_fd[0] = original_lhs\n        }\n      }\n    }\n\n    // step 4\n    for (const fd of result_fds) {\n      const new_fds = new Set(result_fds)\n\n      new_fds.delete(fd)\n\n      if (this.check_fds_are_equivalent(result_fds, new_fds)) {\n        result_fds = new_fds\n      }\n    }\n\n    return result_fds\n  }\n\n  /**\n   * find all the keys\n   *\n   * @param {Set<string>} fds - functional dependencies\n   * @returns Set<Set<string>>\n   */\n  find_all_keys(fds = this.fds) {\n    const number_of_attributes = this.attributes.size\n    const binary_expressions = []\n\n    for (let i = 1; i < 2 ** number_of_attributes; i++) {\n      const expression = []\n      let number = i\n      for (let j = 0; j < number_of_attributes; j++) {\n        expression.push(number % 2)\n        number = number >> 1\n      }\n      binary_expressions.push(expression)\n    }\n\n    binary_expressions.sort((a, b) => {\n      const sum_of_elements_in_a = a.reduce((sum, element) => sum + element, 0)\n      const sum_of_elements_in_b = b.reduce((sum, element) => sum + element, 0)\n      return sum_of_elements_in_a - sum_of_elements_in_b\n    })\n\n    const keys = new Set()\n    const U = [...this.attributes]\n\n    for (const expression of binary_expressions) {\n      const X = new Set()\n\n      for (let i = 0; i < number_of_attributes; i++) {\n        if (expression[i] === 1) {\n          X.add(U[i])\n        }\n      }\n\n      const Xplus = this.find_closure_of_attributes(X, fds)\n      if (\n        set_operation.is_superset(Xplus, this.attributes) &&\n        set_operation.every(keys, key => !set_operation.is_superset(X, key))\n      ) {\n        keys.add(X)\n      }\n    }\n\n    return keys\n  }\n\n  /**\n   * check whether the scheme is in 3NF\n   *\n   * @param {Set<string>} [fds] - functional dependencies\n   * @returns {boolean}\n   */\n  is_in_3NF(fds = this.fds) {\n    const minimal_cover = this.find_minimal_cover(fds)\n    const keys = this.find_all_keys(fds)\n    const prime_attributes = new Set(\n      [...keys].reduce(\n        (union, key) => set_operation.union(union, key),\n        new Set()\n      )\n    )\n\n    for (const fd of minimal_cover) {\n      const array_fd = get_as_object(fd)\n      const X = array_fd[0]\n      const A = array_fd[1][0] // fd.rhs is a singleton because the fd is in the minimal cover\n      const Xplus = this.find_closure_of_attributes(X, fds)\n      if (\n        !set_operation.is_superset(Xplus, this.attributes) && // X is not a superkey\n        !prime_attributes.has(A) // A is not a prime attribute\n      ) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * check whether the scheme is in BCNF\n   *\n   * @param {Set<string>} [fds] - functional dependencies\n   * @returns {boolean}\n   */\n  is_in_BCNF(fds = this.fds) {\n    const minimal_cover = this.find_minimal_cover(fds)\n\n    for (const fd of minimal_cover) {\n      const array_fd = get_as_object(fd)\n      const X = array_fd[0]\n      const Xplus = this.find_closure_of_attributes(X, fds)\n      if (\n        !set_operation.is_superset(Xplus, this.attributes) // X is not a superkey\n      ) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * check whether the scheme is in 4NF\n   *\n   * @param {Set<string>} [fds] - functional dependencies\n   * @returns {boolean}\n   */\n  is_guaranteed_in_4NF(fds = this.fds) {\n    if (!this.is_in_BCNF()) {\n      return false\n    }\n\n    const keys = this.find_all_keys()\n\n    const is_some_key_simple = set_operation.some(keys, key => key.size == 1)\n\n    return is_some_key_simple\n  }\n\n  /**\n   * check whether the scheme is in 5NF\n   *\n   * @param {Set<string>} [fds] - functional dependencies\n   * @returns {boolean}\n   */\n  is_guaranteed_in_5NF(fds = this.fds) {\n    if (!this.is_in_BCNF()) {\n      return false\n    }\n\n    const keys = this.find_all_keys()\n\n    const is_every_key_simple = set_operation.every(keys, key => key.size == 1)\n\n    return is_every_key_simple\n  }\n\n  /**\n   * find a projection of a fd set for a subset\n   *\n   * @param {Set<string>} subset - attributes\n   * @param {boolean} should_minimize - if true, returned fds are minimixed.\n   * @param {Set<string>} [fds] - functional dependencies\n   * @throws {RangeError} - thrown if subset is not included in this.attributes\n   * @returns {Set<string>}\n   */\n  get_projection(subset, should_minimize = true, fds = this.fds) {\n    if (!(set_operation.is_superset(this.attributes, subset))) {\n      throw new RangeError('[' + [...subset] + '] is not included in [' + this.attributes + '].')\n    }\n\n    const number_of_attributes = subset.size\n    const binary_expressions = []\n\n    for (let i = 1; i < 2 ** number_of_attributes; i++) {\n      const expression = []\n      let number = i\n      for (let j = 0; j < number_of_attributes; j++) {\n        expression.push(number % 2)\n        number = number >> 1\n      }\n      binary_expressions.push(expression)\n    }\n\n    let result = new Set()\n    const Z = [...subset]\n\n    for (const expression of binary_expressions) {\n      const X = new Array()\n\n      for (let i = 0; i < number_of_attributes; i++) {\n        if (expression[i] === 1) {\n          X.push(Z[i])\n        }\n      }\n\n      const Xplus = this.find_closure_of_attributes(X, fds)\n      const rhs = set_operation.intersection(Xplus, subset)\n      const array_rhs = [...rhs]\n      const added_fd = generate_fd([X, array_rhs])\n      result.add(added_fd)\n    }\n\n    if (should_minimize) {\n      // NOTE:\n      // Strictly speaking, the minimal cover when the entire attribute set is restricted to\n      // `subset` should be returned, but this is not a problem because the same result is\n      // returned without the restriction. (See the code find_minimal_cover().)\n      result = this.find_minimal_cover(result)\n    }\n    return result\n  }\n\n}\n\n/**\n * synthesize a given fd relation scheme into a 3NF database scheme\n *\n * @param {FdRelationScheme} R1 - fd relation scheme\n * @return {Set<FdRelationScheme>}\n */\nfunction synthesize_into_3NF(R1) {\n  // step 1\n  const minimal_cover = R1.find_minimal_cover()\n\n  // step 2\n  /** @type {Map<string, Set<string>>} */\n  const synthesis = new Map()\n  for (const fd of minimal_cover) {\n    const array_fd = get_as_object(fd)\n    const X = array_fd[0]\n\n    const stringified_X = JSON.stringify(X)\n    if (!(synthesis.has(stringified_X))) {\n      synthesis.set(stringified_X, X)\n    }\n    for (const A of array_fd[1]) {\n      synthesis.get(stringified_X).push(A)\n    }\n  }\n\n  // step 3\n  let is_key_contained = false\n  const keys = R1.find_all_keys()\n  check_key_is_contained: for (const key of keys) {\n    for (const relation_attributes of synthesis.values()) {\n      if (set_operation.is_superset(new Set(relation_attributes), key)) {\n        is_key_contained = true\n        break check_key_is_contained\n      }\n    }\n  }\n  const some_key = [...[...keys][0]]\n  if (!is_key_contained) {\n    const key_stringified = JSON.stringify(some_key.sort())\n    synthesis.set(key_stringified, some_key)\n  }\n\n  // step 4\n  for (const [key, relation_attributes] of synthesis) {\n    for (const [another_key, another_relation_attributes] of synthesis) {\n      if (key === another_key) {\n        continue\n      }\n      if (relation_attributes.size > another_relation_attributes.size) {\n        continue\n      }\n      if (set_operation.is_superset(new Set(another_relation_attributes), new Set(relation_attributes))) {\n        synthesis.delete(key)\n        break\n      }\n\n    }\n  }\n\n  // output\n  const result = new Set()\n  let i = 1\n  for (const relation_attributes of synthesis.values()) {\n\n    result.add(new FdRelationScheme(\n      R1.name + '_' + i,\n      relation_attributes,\n      R1.get_projection(new Set(relation_attributes))\n    ))\n\n    ++i\n  }\n\n  return result\n}\n\nmodule.exports = {\n  generate_fd,\n  FdRelationScheme,\n  synthesize_into_3NF\n}\n\n\n//# sourceURL=webpack:///../node_modules/3NF_SYNTHESIS/index.js?");

/***/ }),

/***/ "../node_modules/3NF_SYNTHESIS/lib/util.js":
/*!*************************************************!*\
  !*** ../node_modules/3NF_SYNTHESIS/lib/util.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\n\n/**\n * get a type\n *\n * @param {any} a - target\n * @returns {string} lowercased type name\n */\nfunction get_type(a) {\n  const type = Object.prototype.toString.call(a).slice(8, -1).toLowerCase()\n  return type\n}\n\n/**\n * Borrow some functions from [a refference page]{@link https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Set}\n */\nconst set_operation = {\n  is_superset: function(set, subset) {\n    for (let elem of subset) {\n      if (!set.has(elem)) {\n        return false\n      }\n    }\n    return true\n  },\n\n  is_equal: function(setA, setB) {\n    return setB.size === setA.size &&\n      this.is_superset(setB, setA)\n  },\n\n  union: function(setA, setB) {\n    let _union = new Set(setA)\n    for (let elem of setB) {\n      _union.add(elem)\n    }\n    return _union\n  },\n\n  intersection: function(setA, setB) {\n    let _intersection = new Set()\n    for (let elem of setB) {\n      if (setA.has(elem)) {\n        _intersection.add(elem)\n      }\n    }\n    return _intersection\n  },\n\n  symmetric_difference: function(setA, setB) {\n    let _difference = new Set(setA)\n    for (let elem of setB) {\n      if (_difference.has(elem)) {\n        _difference.delete(elem)\n      } else {\n        _difference.add(elem)\n      }\n    }\n    return _difference\n  },\n\n  difference: function(setA, setB) {\n    let _difference = new Set(setA)\n    for (let elem of setB) {\n      _difference.delete(elem)\n    }\n    return _difference\n  },\n\n  every: function(A, cond) {\n    for (const elem of A) {\n      if (!cond(elem)) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  some: function(A, cond) {\n    for (const elem of A) {\n      if (cond(elem)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\nmodule.exports = {\n  get_type,\n  set_operation\n}\n\n\n//# sourceURL=webpack:///../node_modules/3NF_SYNTHESIS/lib/util.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./entry.js");
/******/ 	
/******/ })()
;